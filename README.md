1、RTOS内核

一个任务的控制块所包含的信息有：
1，该任务的操作句柄(任务控制块在任务列表的序号变量)地址
2，该任务的名称
3，该任务的状态（block、readly）
4、该任务的Pend状态（pend、unpend）
5，该任务的优先级
6，该任务的所需延时时间变量
7，该任务的私有栈地址
8，该任务的私有栈大小(单位：字，4byte)。
9，该任务的执行函数入口地址

#define	USER_TASK_NUM   4
#define	TASK_NUM   (USER_TASK_NUM+1)
Task_Unit Task_List[TASK_NUM]={0};
用户根据实际需要修改USER_TASK_NUM 变量值，编译器根据TASK_NUM定义一个数组，数组元素为各个任务控制块结构体 ，构成任务列表

RTOS的所有任务由任务创建函数一个一个创建，创建函数如下：
需要向该函数传递的参数有：存储任务ID的变量地址，任务的名称(字符串)，任务的初始化状态，任务的优先级、任务的初始延时值，任务的私有栈大小，任务函数入口地址
该函数根据创建任务的先后顺序将各个任务的控制块信息填入任务列表，其中任务栈的内存空间采用动态内存申请的方式申请MCU的堆区，根据需要可在启动文件中修改堆区大小。


根据任务个数定义用于存放各个任务私有栈顶入口地址的数组
uint32_t PSP_array[TASK_NUM]; 

1，PSP_array[0] = ((unsigned int) task0_stack)+(sizeof task0_stack)-16*4;
task0的任务私有堆栈为数组task0_stack，分布如下：低地址在下，高地址在上，PSP_array[0]记录如下图的pxTopOfStack位置
2，HW32_REG((PSP_array[0] + (14<<2))) = (unsigned long) task0;
PSP_array[0] + (14<<2)指针指向R15（PC），对PC赋值task0任务函数地址入口
3，HW32_REG((PSP_array[0] + (15<<2))) = 0x01000000;
PSP_array[0] + (15<<2)指针指向xPSR。初始化xPSR为24bit为1（该位代表thumb状态，若为0会引起错误异常）

由冒泡排序法根据任务的优先级大小对任务列表进行排序，低优先级的任务，IDLE_Task的优先级为0，处于任务数组的第一个元素。
最高优先级处在任务数组的最后一个元素，同等优先级任务根据创建先后进行排序，同时更新任务的ID值，IDLE_Task的优先级最低，处于任务数组的第一个，其ID=0；




RTOS初始化：

用变量current_task和next_task指示当前任务和上一个任务的私有栈地址在PSP_array中的位置，实质是私有栈的切换变量
current_task=0,则使用task0的私有栈，
__set_PSP((PSP_array[current_task] + 16*4));//将MCU的PSP指向task0的栈顶位置（如下图）


NVIC_SetPriority(PendSV_IRQn,0xFF);//设置PendSV中断的优先级为最低优先级（MCU中断编号规则是，值越大，优先级越低）



SysTick_Config(SysTick_Rhythm*(SystemCoreClock/1000000));
定义systick时间片的时间单元，单位us
SysTick_Config(SysTick_Rhythm*(SystemCoreClock/1000000));
SystemCoreClock为系统内核时钟频率，1/SystemCoreClock秒产生一次SysTick计数，SysTick_Rhythm*(SystemCoreClock/1000000)次产生一次中断，
即SysTick_Rhythm微秒产生一次中断，操作系统时间片为SysTick_Rhythm微秒。

__set_CONTROL(0x03);
control[0] control[1] 选择 1 1 模式
即：使用PSP（进程栈），非特权模式

ISB
指令同步隔离。它会清洗流水线，以保证所有它前面的指令都执行完毕之后，才执行它后面的指令。
Idle_task();
开始执行Idle_Task任务


main函数中先完成板级硬件的初始化，后完成上述的任务创建和RTOS的初始化


任务延时：

RTOS_delay函数中根据task_id选择对不同的任务进行状态设置和对应的延时变量赋值，并进入任务阻塞状态
1，将当前任务设置为Block状态，（不参与后续的任务优先级判决），释放CPU使用权。
2，对当前任务的延时变量赋值，赋值为当前滴答定时器的计数值+所需延时的值。
3，任务进入阻塞态，等待滴答定时器中断判决延时时间到，修改该任务的状态为Ready态
4、每次时间片中断都会检测延时计数变量是否等于当前任务的延时变量值，若是则会将当前任务的状态设置为Ready状态，从而结束阻塞状态，进入优先级判决，等待运行

任务调度：

1，在RTOS时间片中断函数中对延时计数变量++操作，代表一个心跳时钟计数
2，对任务列表每个任务的延时值轮询，判断延时时间是否已到，若某任务延时时间到且该任务未被设置为挂起态，则将该任务解除阻塞，设置为ready态，（每个任务都必须检查到，所以必须轮询TASK_NUM次，固定时间）
3，对任务列表从高优先级到低优先级，依次判断任务是否ready态，第一个出现Ready态的任务为当前ready态任务中优先级最高的任务，记录当前 i 值即为任务优先级判决的ID值，并不在继续轮询查找，Task_Flag起到作用
4，对返回的最高优先级任务编号与当前正在运行的任务编号进行比较，若相同，则无需启动PensSV中断，systick中断退出，继续执行当前的任务
5，若判决出更高优先级的任务，设置PendSV为Ready 状态，待后续进入PendSV中断函数，进行任务的上下文切换。


任务的上下文切换：（分两个部分，当前任务的现场保护，下一个任务的现场恢复）
现场保护：
1，当前任务的R4-R11中的数据压入当前任务的私有栈
2，把当前任务的编号保存到R2中
3，把当前任务的私有栈PSP所指地址存取PSP_array数组中对应元素中。
其实质是：保存了当前任务的R4-R11中的数据压入当前任务的私有栈，和当前任务的私有栈PSP所指地址存取PSP_array数组中对应元素中

现场恢复：
1，将current_task = next_task
2,  将next_task任务的私有栈PSP所对应取PSP_array数组中对应元素加载到R0。
3，将R0（PSP_array所存储的指针地址）读取数据恢复到R4-R11
4，将R0（PSP_array所存储的指针地址）恢复到系统PSP
5，PC跳转到进入PendSV函数前的入口地址
其实质是：从任务的私有栈恢复数据到R4-R11，并将当前任务的堆栈地址赋值给系统PSP，将LR地址加载到PC实现函数返回



以上几个寄存器的压栈过程由硬件自动完成



通过同时修改任务的运行状态和挂起状态，可实现任务的挂起和解除操作，
1，设置任务的运行状态和挂起状态为阻塞态，则任务不在参与优先级判决，挂起的任务对于调度器而言，相当于不可见
2，解除任务的挂起态，同时让该任务的运行态为ready态，参与优先级的判决，等待CPU使用权

临界段保护：
int __svc(0x00) SVC(void);

通过调用SVC()函数可实现任务在非特权模式下，呼叫CPU进入异常处理，在SCV异常中断处理服务函数中设置CPU的模式



退出SVC中断后设置PRIMASK值为1，屏蔽除NMI和HardFault之外的所有异常和中断，实现临界段保护而不被其他事物打断。

，退出临界段保护，先关闭PRIMASK，在将CPU设置到用户态。

空闲线程：

空闲线程，在创建之初就已设置为优先级最低0，无延时，永远处于ready或run态，可在IDLE_Task函数中添加内存回收或CPU进给休眠，或系统运行参数监控等相关操作

用户线程：

任务的组成由while(1)中任务实体执行部分和主动释放CPU后延时部分组成，若任务无需延时，2000可改为0，但此任务的优先级过高会完全抢占比其低优先级任务的CPU使用权。

中断服务函数：
在BSP初始化函数中对各种硬件中断进行初始化，优先级设置操作，在对应中断服务函数中编写中断所需执行代码，注意快进快出，任何中断的优先级都大于Task的优先级



消息队列：
消息队列采用单链表式，实现数据的先进先出FIFO功能，






二值，互斥，计数信号量：
二值信号量主要实现任务间的同步，可以是两个任务间同步，也可以是一个任务与多个任务之间同步。
互斥信号量主要实现两个任务间的互斥运行，用于共享资源保护，实现互斥访问，也可应用于一个任务与多个任务间的互斥，当多个任务阻塞在同一个互斥信号量时，信号量解除后，率先解除的是阻塞任务中优先级最高的任务。
计数信号量主要用于资源的管理统计，对某一共享资源的数量进行管理，当资源数为0时，任务可能会阻塞在该计数信号量上，当资源数大于0时，阻塞在该计数信号量上的任务中，优先级最高的任务率先解除阻塞，获得资源。





